{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": false,
    "environment": "Default Environment",
    "integration": "CBCloud",
    "identifier": "VMware Carbon Black Cloud Alerts and Events Baseline Connector_b813a51a-e12b-4e52-b3b9-bce7c32bd6e9",
    "connectorDefinitionName": "VMware Carbon Black Cloud Alerts and Events Baseline Connector",
    "displayName": "VMware Carbon Black Cloud Alerts and Events Baseline Connector",
    "description": "Fetch Carbon Black Cloud Alerts and Events that reached specific baseline (were classified by default as Threat in Carbon Black Cloud)",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "4",
    "pythonVersion": 3,
    "isAllowlistSupported": true,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Username",
            "paramValue": "",
            "description": "Proxy server username",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Password",
            "paramValue": "",
            "description": "Proxy server password",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alerts Backlog Timer",
            "paramValue": "60",
            "description": "Time frame in minutes for which connector should try to fetch again the alerts from backlog it previously failed to process.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Backlog Alerts per Cycle",
            "paramValue": "10",
            "description": "How many alerts  connector should try to fetch from the backlog during one connector run.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Events Limit to Ingest per Alert",
            "paramValue": "25",
            "description": "Specify how many events can be ingested per single CB Cloud alert.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "http://127.0.0.1:8866",
            "description": "Proxy server to use for connection.",
            "type": 4,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Offset Time In Hours",
            "paramValue": "2400",
            "description": "Number of hours before the first connector iteration to retrieve alerts from. This parameter applies to the initial connector iteration after you enable the connector for the first time, or used as a fallback value in cases where connector's last run timestamp expires.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Name Template",
            "paramValue": "",
            "description": "If specified, connector will use this value from the CB Cloud API response for alert data for Siemplify Alert Name. You can provide placeholders in the following format: [name of the field]. Example: CBCLOUD Alert - [reason]. Note: the maximum length for the field is 256 characters. If nothing is provided or user provides an invalid template, connector will use the default alert name.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "180",
            "description": "The timeout limit (in seconds) for the python process running current script",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Describes the name of the field where the environment name is stored. If the environment field isn't found, the environment is \"\"",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the \"Environment Field Name\" field. Default is .* to catch all and return the value unchanged. Used to allow the user to manipulate the environment field via regex logic. If the regex pattern is null or empty, or the environment value is null, the final environment result is \"\"",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Root",
            "paramValue": "https://defense.conferdeploy.net/api",
            "description": "Vmware Carbon Black Cloud API Root URL",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Organization Key",
            "paramValue": "7DESJ9GN",
            "description": "Vmware Carbon Black Cloud Organization Key, Eg. 7DDDD9DD",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API ID",
            "paramValue": "***************",
            "description": "Vmware Carbon Black Cloud API ID (Custom API Key ID)",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Secret Key",
            "paramValue": "***************",
            "description": "Vmware Carbon Black Cloud API Secret Key (Custom API Secret Key)",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "Verify SSL certificates for HTTPS requests to Microsoft Azure.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Alerts Per Cycle",
            "paramValue": "100",
            "description": "How many alerts should be processed during one connector run.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Minimum Severity to Fetch",
            "paramValue": "4",
            "description": "Minimum severity of Carbon Black Cloud alert to be ingested to Siemplify, for example, 4 or 7",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "What Alert Field to use for Name field",
            "paramValue": "type",
            "description": "What Carbon Black Cloud alert field should be used for the Siemplify Alert Name field. Possible values are: type, policy_name",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "What Alert Field to use for Rule Generator",
            "paramValue": "type",
            "description": "What Carbon Black Cloud alert field should be used for the Siemplify Alert Rule Generator field. Possible values are: type, policy_name",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Reputation to Ingest",
            "paramValue": "",
            "description": "What Carbon Black Cloud alert reputation alert can have to be ingested. Parameter accepts multiple values as a comma separated string. If \"N/A\" is provided, connector will ingest alerts without reputation.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Watchlist Name Filter",
            "paramValue": "",
            "description": "If provided, for CB Cloud alerts with the type \u201cWatchlist\u201c ingest only that were triggered by the respective whatchlist. Parameter accepts multiple values as a comma separated string. If nothing is specified - ingest everything regardless of watchlist name.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Rule Generator Template",
            "paramValue": "",
            "description": "If specified, connector will use this value from the CB Cloud API response for alert data for Siemplify Rule Generator. You can provide placeholders in the following format: [name of the field]. Example: CBCLOUD - [reason]. Note: the maximum length for the field is 256 characters. If nothing is provided or user provides an invalid template, connector will use the default rule generator value.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 35.0,
    "isScriptConnector": true,
    "script": "import sys\nimport arrow\nfrom CBCloudManager import CBCloudManager\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyUtils import output_handler, unix_now\n\nfrom exceptions import CBCloudException\nfrom TIPCommon import (\n    extract_connector_param,\n    is_overflowed,\n    get_last_success_time,\n    save_timestamp,\n    string_to_multi_value,\n)\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\nfrom constants import (\n    BASELINE_CONNECTOR_NAME,\n    DEFAULT_ALERT_FIELD_FOR_RULE_GENERATOR,\n    DEFAULT_ALERT_FIELD_FOR_RULE_NAME,\n    DEFAULT_EVENTS_LIMIT_TO_INGEST_PER_ALERT,\n    DEFAULT_MAX_ALERTS_PER_CYCLE,\n    DEFAULT_MAX_BACKLOG_ALERTS_PER_CYCLE,\n    KEY_FOR_SAVED_ALERTS,\n    MAP_FILE,\n)\nfrom utils import (\n    TIMEOUT_THRESHOLD,\n    is_approaching_timeout,\n    validate_alert_name_field_name,\n    validate_rule_generator_field_name,\n    add_alert_to_backlog,\n    add_events_to_alert_info,\n    remove_backlog_alert,\n    backlog_ids_exists,\n    read_offense_events,\n    read_backlog_ids,\n    remove_backlog_alert_by_id,\n    save_backlog_ids,\n    save_alerts,\n    pass_filters,\n)\n\nEMPTY_ALERTS_JSON_FILE = {KEY_FOR_SAVED_ALERTS: {}}\nDEFAULT_OFFSET_TIME_HOURS = 24\nMAX_ENRICHED_EVENTS_PER_REQUEST = 10\nCONNECTOR_STARTING_TIME = unix_now()\n\n\ndef is_alert_already_seen(alert, existing_alerts):\n    return bool(existing_alerts.get(alert.id_with_legacy_id))\n\n\ndef get_events(siemplify, alert, manager, max_events_per_alert, python_process_timeout):\n    event_details = []\n    processed_event_ids = []\n    all_event_ids = [\n        event.observation_id\n        for event in manager.get_events_by_alert_id(\n            alert_id=alert.legacy_alert_id, max_events_to_return=max_events_per_alert\n        )\n    ]\n    siemplify.LOGGER.info(\n        f'Successfully received \"{len(all_event_ids)}\" new events for alert \"{alert.id_for_logging}\"'\n    )\n\n    for event_ids in [\n        all_event_ids[x : x + MAX_ENRICHED_EVENTS_PER_REQUEST]\n        for x in range(0, len(all_event_ids), MAX_ENRICHED_EVENTS_PER_REQUEST)\n    ]:\n        if is_approaching_timeout(\n            python_process_timeout, CONNECTOR_STARTING_TIME, TIMEOUT_THRESHOLD\n        ):\n            siemplify.LOGGER.info(\n                \"Timeout is approaching. Connector will gracefully exit.\"\n            )\n            break\n        event_details.extend(\n            manager.get_events_detailed_information(event_ids=event_ids)\n        )\n        processed_event_ids.extend(event_ids)\n    return processed_event_ids, event_details\n\n\ndef attach_events_to_alert_info(\n    siemplify, alert, alert_info, manager, max_events_per_alert, python_process_timeout\n):\n    event_ids = []\n    is_attached = True\n    try:\n        if not alert.has_events:\n            siemplify.LOGGER.info(\n                f\"Alert of type {alert.type} with no additional events.\"\n            )\n            alert_info = add_events_to_alert_info(\n                alert_info, [alert], alert.id_for_logging\n            )\n            event_ids = [alert.id]\n        else:\n            event_ids, events_details = get_events(\n                siemplify, alert, manager, max_events_per_alert, python_process_timeout\n            )\n            siemplify.LOGGER.info(\n                f'Successfully loaded \"{len(event_ids)}\" events for alert'\n            )\n            alert_info = add_events_to_alert_info(\n                alert_info, events_details, alert.id_for_logging\n            )\n    except CBCloudException as e:\n        siemplify.LOGGER.info(e)\n        is_attached = False\n    except Exception as e:\n        siemplify.LOGGER.error(\n            f'Failed to load events for alert \"{alert.id_for_logging}\"'\n        )\n        siemplify.LOGGER.exception(e)\n        is_attached = False\n    return alert_info, event_ids, is_attached\n\n\ndef finish_alert_processing(\n    siemplify, alert_info, alert, processed_alerts, processed_alert_ids\n):\n    processed_alerts.append(alert_info)\n    processed_alert_ids.append(alert.id_with_legacy_id)\n    siemplify.LOGGER.info(f'Cases for alert \"{alert.id_for_logging}\" was created.')\n    return processed_alerts, processed_alert_ids\n\n\ndef process_backlog_alerts(\n    siemplify,\n    manager,\n    backlog_ids_to_process,\n    max_backlog_alerts,\n    environment_common,\n    alert_name_field_name,\n    rule_generator_field_name,\n    events_limit_to_ingest_per_alert,\n    python_process_timeout,\n    processed_alerts,\n    processed_alert_ids,\n    alert_name_template=None,\n    rule_generator_template=None,\n):\n    siemplify.LOGGER.info(\"Processing backlog alerts\")\n    backlog_alerts = manager.get_alerts_by_id(\n        list(backlog_ids_to_process.keys()), max_backlog_alerts\n    )\n    siemplify.LOGGER.info(f\"Loaded {len(backlog_alerts)} backlog alerts\")\n    for backlog_alert in backlog_alerts:\n        alert_info_without_events = backlog_alert.to_alert_info(\n            environment_common,\n            alert_name_field_name,\n            rule_generator_field_name,\n            alert_name_template=alert_name_template,\n            rule_generator_template=rule_generator_template,\n        )\n\n        alert_info, event_ids, is_attached = attach_events_to_alert_info(\n            siemplify=siemplify,\n            alert=backlog_alert,\n            alert_info=alert_info_without_events,\n            manager=manager,\n            max_events_per_alert=events_limit_to_ingest_per_alert,\n            python_process_timeout=python_process_timeout,\n        )\n\n        if not alert_info or not is_attached:\n            siemplify.LOGGER.info(\n                f\"Failed to process backlog alert {backlog_alert.id_for_logging}.\"\n            )\n            continue\n\n        backlog_ids_to_process = remove_backlog_alert(\n            siemplify, backlog_ids_to_process, backlog_alert\n        )\n        siemplify.LOGGER.info(\n            f\"Backlog alert {backlog_alert.id_for_logging} processed successfully.\"\n        )\n\n        processed_alerts, processed_alert_ids = finish_alert_processing(\n            siemplify, alert_info, backlog_alert, processed_alerts, processed_alert_ids\n        )\n    return processed_alerts, processed_alert_ids, backlog_ids_to_process\n\n\ndef save_alert_json(siemplify, alert, offense_events):\n    \"\"\"\n    Save new alert to the offense_events.json file\n    :param siemplify: {Alert} Siemplify instance\n    :param alert: {Alert} The alert to save\n    :param offense_events: Offense events\n    \"\"\"\n    # If alert does not exist in offense_events.json file - add new alert to file\n    if alert.id_with_legacy_id not in offense_events[KEY_FOR_SAVED_ALERTS].keys():\n        siemplify.LOGGER.info(\n            f\"Alert {alert.id_with_legacy_id} was not found in offense.json file. Creating new record\"\n        )\n        # Offense was never in the offense events file. Need to create new record\n        offense_events[KEY_FOR_SAVED_ALERTS][alert.id_with_legacy_id] = {\n            \"last_seen_time\": unix_now()\n        }\n\n\n@output_handler\ndef main(is_test_run):\n    processed_alerts = []\n    processed_alert_ids = []\n    all_alerts = []\n    alerts_from_api = []\n    new_backlog_alerts = []\n    should_process_backlog_alerts = True\n    siemplify = SiemplifyConnectorExecution()\n    siemplify.script_name = BASELINE_CONNECTOR_NAME\n\n    if is_test_run:\n        siemplify.LOGGER.info(\n            \"***** This is an 'IDE Play Button' 'Run Connector once' test run ******\"\n        )\n\n    siemplify.LOGGER.info(\"----------------- Main - Param Init -----------------\")\n\n    environment_field_name = extract_connector_param(\n        siemplify, param_name=\"Environment Field Name\", print_value=True\n    )\n\n    environment_regex_pattern = extract_connector_param(\n        siemplify, param_name=\"Environment Regex Pattern\", print_value=True\n    )\n\n    python_process_timeout = extract_connector_param(\n        siemplify,\n        param_name=\"PythonProcessTimeout\",\n        input_type=int,\n        is_mandatory=True,\n        print_value=True,\n    )\n\n    api_root = extract_connector_param(\n        siemplify, param_name=\"API Root\", is_mandatory=True, print_value=True\n    )\n\n    org_key = extract_connector_param(\n        siemplify, param_name=\"Organization Key\", is_mandatory=True, print_value=True\n    )\n\n    api_id = extract_connector_param(siemplify, param_name=\"API ID\", is_mandatory=True)\n\n    api_secret_key = extract_connector_param(\n        siemplify, param_name=\"API Secret Key\", is_mandatory=True\n    )\n\n    verify_ssl = extract_connector_param(\n        siemplify, param_name=\"Verify SSL\", input_type=bool, print_value=True\n    )\n\n    offset_time_in_hours = extract_connector_param(\n        siemplify,\n        param_name=\"Offset Time In Hours\",\n        input_type=int,\n        is_mandatory=True,\n        print_value=True,\n        default_value=DEFAULT_OFFSET_TIME_HOURS,\n    )\n\n    max_alerts_per_cycle = extract_connector_param(\n        siemplify,\n        param_name=\"Max Alerts Per Cycle\",\n        input_type=int,\n        is_mandatory=True,\n        print_value=True,\n        default_value=DEFAULT_MAX_ALERTS_PER_CYCLE,\n    )\n\n    min_severity = extract_connector_param(\n        siemplify, param_name=\"Minimum Severity to Fetch\", print_value=True\n    )\n\n    alert_name_field_name = extract_connector_param(\n        siemplify,\n        param_name=\"What Alert Field to use for Name field\",\n        is_mandatory=True,\n        print_value=True,\n        default_value=DEFAULT_ALERT_FIELD_FOR_RULE_NAME,\n    )\n\n    rule_generator_field_name = extract_connector_param(\n        siemplify,\n        param_name=\"What Alert Field to use for Rule Generator\",\n        is_mandatory=True,\n        print_value=True,\n        default_value=DEFAULT_ALERT_FIELD_FOR_RULE_GENERATOR,\n    )\n\n    alert_reputations_to_ingest = extract_connector_param(\n        siemplify,\n        param_name=\"Alert Reputation to Ingest\",\n        is_mandatory=False,\n        print_value=True,\n    )\n\n    events_limit_to_ingest_per_alert = extract_connector_param(\n        siemplify,\n        param_name=\"Events Limit to Ingest per Alert\",\n        is_mandatory=True,\n        default_value=DEFAULT_EVENTS_LIMIT_TO_INGEST_PER_ALERT,\n        input_type=int,\n        print_value=True,\n    )\n\n    watchlist_name_filter = string_to_multi_value(\n        extract_connector_param(\n            siemplify, param_name=\"Watchlist Name Filter\", print_value=True\n        )\n    )\n\n    alerts_backlog_timer = extract_connector_param(\n        siemplify, param_name=\"Alerts Backlog Timer\", input_type=int, print_value=True\n    )\n\n    max_backlog_alerts = extract_connector_param(\n        siemplify,\n        param_name=\"Max Backlog Alerts per Cycle\",\n        input_type=int,\n        print_value=True,\n        default_value=DEFAULT_MAX_BACKLOG_ALERTS_PER_CYCLE,\n    )\n\n    alert_name_template = extract_connector_param(\n        siemplify, param_name=\"Alert Name Template\", print_value=True\n    )\n\n    rule_generator_template = extract_connector_param(\n        siemplify, param_name=\"Rule Generator Template\", print_value=True\n    )\n\n    siemplify.LOGGER.info(\"------------------- Main - Started -------------------\")\n\n    try:\n        validate_alert_name_field_name(alert_name_field_name)\n        validate_rule_generator_field_name(rule_generator_field_name)\n\n        environment_common = GetEnvironmentCommonFactory.create_environment_manager(\n            siemplify, environment_field_name, environment_regex_pattern, MAP_FILE\n        )\n\n        last_success_time = get_last_success_time(\n            siemplify, offset_with_metric={\"hours\": offset_time_in_hours}\n        )\n\n        manager = CBCloudManager(\n            api_root=api_root,\n            org_key=org_key,\n            api_id=api_id,\n            api_secret_key=api_secret_key,\n            verify_ssl=verify_ssl,\n            logger=siemplify.LOGGER,\n        )\n\n        alerts_from_api = manager.get_alerts(\n            start_time=last_success_time.isoformat(),\n            end_time=arrow.utcnow().isoformat(),\n            min_severity=min_severity,\n            sort_order=\"ASC\",\n            workflows=[\"OPEN\"],\n            sort_by=\"backend_timestamp\",\n            limit=max_alerts_per_cycle,\n        )\n        alerts_from_api = sorted(\n            alerts_from_api, key=lambda alert: alert.create_time_ms\n        )\n        siemplify.LOGGER.info(\n            f'Fetched alerts {\", \".join([alert.id_for_logging for alert in alerts_from_api])}'\n        )\n\n        siemplify.LOGGER.info(\"Reading already existing alerts...\")\n\n        existing_alerts = read_offense_events(\n            siemplify, EMPTY_ALERTS_JSON_FILE.get(KEY_FOR_SAVED_ALERTS)\n        )\n\n        siemplify.LOGGER.info(f\"fetched already existing alerts:\\n{existing_alerts}\")\n\n        alert_legacy_ids = []\n        for alert in alerts_from_api:\n            try:\n                if is_approaching_timeout(\n                    python_process_timeout, CONNECTOR_STARTING_TIME, TIMEOUT_THRESHOLD\n                ):\n                    siemplify.LOGGER.info(\n                        \"Timeout is approaching. Connector will gracefully exit\"\n                    )\n                    break\n                if len(processed_alerts) >= max_alerts_per_cycle:\n                    siemplify.LOGGER.info(\n                        f\"Maximum alerts count ({max_alerts_per_cycle}) reached! Stopping \"\n                        f\"processing alerts\"\n                    )\n                    break\n                if is_test_run and processed_alerts:\n                    siemplify.LOGGER.info(\n                        \"Maximum alerts count (1) for test run reached!\"\n                    )\n                    break\n                siemplify.LOGGER.info(f\"Starting alert with id: {alert.id_for_logging}\")\n                all_alerts.append(alert)\n\n                # Check if already processed\n                siemplify.LOGGER.info(f\"LEGACY_ID::{existing_alerts.get(alert.id_with_legacy_id)}\")\n                siemplify.LOGGER.info(f\"IS_ALERT_SEEN {is_alert_already_seen(alert, existing_alerts)}\")\n                if is_alert_already_seen(alert, existing_alerts):\n                    siemplify.LOGGER.info(\n                        f'Alert \"{alert.id_for_logging}\" already processed. Skipping...'\n                    )\n                    continue\n                # Check if alert passes filters\n                if not pass_filters(\n                    siemplify=siemplify,\n                    alert=alert,\n                    watchlist_name_filter=watchlist_name_filter,\n                    alert_reputations_to_ingest=alert_reputations_to_ingest,\n                ):\n                    continue\n                siemplify.LOGGER.info(\n                    f\"Processing alert with id: {alert.id_for_logging}\"\n                )\n\n                alert_info_without_events = alert.to_alert_info(\n                    environment_common,\n                    alert_name_field_name,\n                    rule_generator_field_name,\n                    alert_name_template=alert_name_template,\n                    rule_generator_template=rule_generator_template,\n                )\n                disable_overflow = True\n                if (\n                        not disable_overflow\n                        and is_overflowed(siemplify, alert_info_without_events, is_test_run)\n                ):\n                    siemplify.LOGGER.info(\n                        f\"{alert_info_without_events.rule_generator}-{alert_info_without_events.ticket_id}-{alert_info_without_events.environment}-{alert_info_without_events.device_product} found as overflow alert. Skipping.\"\n                    )\n                    # If is overflowed we should skip\n                    continue\n\n                alert_info, event_ids, is_attached = attach_events_to_alert_info(\n                    siemplify=siemplify,\n                    alert=alert,\n                    alert_info=alert_info_without_events,\n                    manager=manager,\n                    max_events_per_alert=events_limit_to_ingest_per_alert,\n                    python_process_timeout=python_process_timeout,\n                )\n                if not alert_info or not is_attached:\n                    new_backlog_alerts = add_alert_to_backlog(\n                        siemplify, new_backlog_alerts, alert\n                    )\n                    continue\n\n                processed_alerts, processed_alert_ids = finish_alert_processing(\n                    siemplify, alert_info, alert, processed_alerts, processed_alert_ids\n                )\n                alert_legacy_ids.append(alert.legacy_alert_id)\n\n            except Exception as e:\n                siemplify.LOGGER.error(\n                    f\"Failed to process alert with id {alert.id_for_logging}\"\n                )\n                siemplify.LOGGER.exception(e)\n\n                if is_test_run:\n                    raise\n\n        # Backlog alerts\n        backlog_ids_to_process, total_backlog_ids = read_backlog_ids(\n            siemplify, alerts_backlog_timer\n        )\n        is_backlog_empty = not bool(backlog_ids_exists(backlog_ids_to_process))\n\n        backlog_alerts_to_remove = {\n            _id: value\n            for _id, value in backlog_ids_to_process.items()\n            if _id in alert_legacy_ids\n        }\n        for key, value in backlog_alerts_to_remove.items():\n            siemplify.LOGGER.info(\n                f\"Alert with ID: {key} was already processed and will be removed from backlog.\"\n            )\n            remove_backlog_alert_by_id(siemplify, backlog_ids_to_process, key)\n\n        if is_backlog_empty or is_approaching_timeout(\n            python_process_timeout, CONNECTOR_STARTING_TIME, TIMEOUT_THRESHOLD\n        ):\n            (\n                siemplify.LOGGER.info(\"No backlog id to process.\")\n                if is_backlog_empty\n                else siemplify.LOGGER.info(\n                    \"Timeout is approaching. Backlog alerts will not be processed.\"\n                )\n            )\n\n            should_process_backlog_alerts = False\n\n        if should_process_backlog_alerts:\n            processed_alerts, processed_alert_ids, backlog_ids_to_process = (\n                process_backlog_alerts(\n                    siemplify,\n                    manager,\n                    backlog_ids_to_process,\n                    max_backlog_alerts,\n                    environment_common,\n                    alert_name_field_name,\n                    rule_generator_field_name,\n                    events_limit_to_ingest_per_alert,\n                    python_process_timeout,\n                    processed_alerts,\n                    processed_alert_ids,\n                    alert_name_template=alert_name_template,\n                    rule_generator_template=rule_generator_template,\n                )\n            )\n\n        if not is_test_run:\n            save_backlog_ids(siemplify, backlog_ids_to_process, new_backlog_alerts)\n\n            if processed_alert_ids:\n                save_alerts(\n                    siemplify,\n                    existing_alerts,\n                    processed_alert_ids,\n                    offset_time_in_hours,\n                    EMPTY_ALERTS_JSON_FILE,\n                )\n            if all_alerts:\n                save_timestamp(\n                    siemplify, alerts=all_alerts, timestamp_key=\"create_time_ms\"\n                )\n\n    except Exception as e:\n        siemplify.LOGGER.error(f\"General error: {e}\")\n        siemplify.LOGGER.exception(e)\n\n        if is_test_run:\n            raise\n\n    siemplify.LOGGER.info(\n        f\"Alert processed: {len(all_alerts)} out of {len(alerts_from_api)}\"\n    )\n    siemplify.LOGGER.info(f\"Created total of {len(processed_alerts)} cases\")\n\n    siemplify.LOGGER.info(\"------------------- Main - Finished -------------------\")\n    siemplify.return_package(processed_alerts)\n\n\nif __name__ == \"__main__\":\n    is_test = not (len(sys.argv) < 2 or sys.argv[1] == \"True\")\n    main(is_test)\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/vmware-carbon-black-cloud#vmware-carbon-black-cloud-alerts-and-events-baseline-connector",
    "deviceProductField": "ProductName",
    "eventNameField": "event_type",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}