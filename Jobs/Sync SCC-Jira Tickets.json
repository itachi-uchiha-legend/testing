{
    "lastRunStatus": 0,
    "lastRunTime": 1751017036874,
    "uniqueIdentifier": "14fc2aac-f8a3-41cf-bfb0-5992e9b6a221",
    "id": 0,
    "jobDefinitionId": 0,
    "name": "Sync SCC-Jira Tickets",
    "integration": "SCCEnterprise",
    "script": "\"\"\"BiDi Sync job SOAR <-> Jira\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom datetime import datetime\nfrom typing import Iterable, Mapping, Sequence\n\nfrom SiemplifyJob import SiemplifyJob\nfrom TIPCommon import extraction\nfrom TIPCommon import validation\nfrom TIPCommon import consts\n\nimport JiraConstants\nimport JiraDatamodels\nimport SCCEnterpriseDatamodels\nimport SCCEnterpriseUtils\nfrom BaseSoarItsmJob import SyncSoarITSM\nfrom JiraManager import JiraManager\nfrom SCCEnterpriseConsts import NOT_AVAILABLE, RESOLVED_STATUS, SYNC_SCC_JIRA_TICKETS\n\n\n@dataclasses.dataclass\nclass JiraAuthParams:\n    api_root: str\n    username: str\n    api_token: str\n    verify_ssl: bool\n\n    @classmethod\n    def build_from_job(cls, chronicle_soar: SiemplifyJob) -> JiraAuthParams:\n        \"\"\"Build integration auth params from SOAR job object.\"\"\"\n        return cls(\n            api_root=extraction.extract_job_param(\n                chronicle_soar, param_name=\"API Root\", is_mandatory=True\n            ),\n            username=extraction.extract_job_param(\n                chronicle_soar, param_name=\"Username\", is_mandatory=True\n            ),\n            api_token=extraction.extract_job_param(\n                chronicle_soar, param_name=\"API Token\", is_mandatory=True\n            ),\n            verify_ssl=extraction.extract_job_param(\n                chronicle_soar,\n                param_name=\"Verify SSL\",\n                is_mandatory=True,\n                input_type=bool,\n            ),\n        )\n\n\nclass SyncSCCJiraTicketsJob(SyncSoarITSM[JiraDatamodels.Issue, JiraManager]):\n    \"\"\"Implementation of SyncSoarITSM using ServiceNow\"\"\"\n\n    def _validate_params(self) -> None:\n        validator = validation.ParameterValidator(self.soar_job)\n        self.params.max_hours_backwards = validator.validate_non_negative(\n            param_name=\"Max Hours Backwards\", value=self.params.max_hours_backwards\n        )\n\n    def _init_api_clients(self) -> JiraManager:\n        \"\"\"Initialize the Jira manager.\"\"\"\n        jira_auth_params = JiraAuthParams.build_from_job(self.soar_job)\n        return JiraManager(\n            server_addr=jira_auth_params.api_root,\n            username=jira_auth_params.username,\n            api_token=jira_auth_params.api_token,\n            verify_ssl=jira_auth_params.verify_ssl,\n            logger=self.soar_job.LOGGER,\n        )\n\n    def _get_environment_for_case_filter(self) -> str:\n        return self.params.environment\n\n    def _get_max_hours_backwards(self) -> int:\n        return self.params.max_hours_backwards\n\n    def _get_bulk_ticket_id_to_details_map(\n        self,\n        ticket_ids: Sequence[str] | None = None,\n        last_run_timestamp: int | None = None,\n    ) -> Mapping[str, JiraDatamodels.Issue]:\n        source_link_field_id = self.api_client.get_field_id_by_name(\n            project_id=JiraConstants.SCCE_PROJECT_KEY,\n            issue_type_id=(\n                self.api_client.jira.issue_type_by_name(\n                    JiraConstants.CUSTOM_ISSUE_TYPE_NAME\n                ).id\n            ),\n            field_name=\"Source Link\",\n        )\n        read_mask = [\n            \"key\",\n            \"assignee\",\n            \"updated\",\n            \"description\",\n            \"status\",\n            \"priority\",\n            \"comment\",\n            source_link_field_id,\n        ]\n\n        if last_run_timestamp:\n            issues = self.api_client.search_issues(\n                project_key_list=[JiraConstants.SCCE_PROJECT_NAME],\n                issue_type_list=[JiraConstants.CUSTOM_ISSUE_TYPE_NAME],\n                updated_from=last_run_timestamp,\n                fields=read_mask,\n            )\n\n        else:\n            issues = self.api_client.search_issues_by_keys(\n                project_key_list=[JiraConstants.SCCE_PROJECT_NAME],\n                issue_type_list=[JiraConstants.CUSTOM_ISSUE_TYPE_NAME],\n                key_list=ticket_ids,\n                fields=read_mask,\n            )\n\n        issues_mapping = {}\n        for issue in issues:\n            issue.case_uri = issue.raw_fields.get(source_link_field_id) or \"\"\n            issues_mapping[issue.key] = issue\n\n        return {issue.key: issue for issue in issues}\n\n    def _get_ticket_id_to_details_map(\n        self, ticket_id: str\n    ) -> Mapping[str, JiraDatamodels.Issue]:\n        return self._get_bulk_ticket_id_to_details_map([ticket_id])\n\n    def _get_bulk_ticket_id_to_comments_map(\n        self, tickets: Iterable[JiraDatamodels.Issue]\n    ) -> Mapping[str, list[str]]:\n        return {\n            issue.key: [comment.body for comment in issue.comments] for issue in tickets\n        }\n\n    def _get_ticket_id_to_comments_map(\n        self, ticket: JiraDatamodels.Issue\n    ) -> Mapping[str, list[str]]:\n        return self._get_bulk_ticket_id_to_comments_map([ticket])\n\n    def _add_comment_to_ticket(self, comment: str, ticket_id: str) -> None:\n        self.api_client.add_comment(ticket_id, comment)\n\n    def _close_ticket(self, ticket_id: str) -> None:\n        self.api_client.update_issue(ticket_id, status=RESOLVED_STATUS)\n\n    def _get_ticket_case_uri(self, ticket: JiraDatamodels.Issue) -> str:\n        return ticket.case_uri\n\n    def _get_ticket_status(self, ticket: JiraDatamodels.Issue) -> str:\n        return ticket.status\n\n    def _set_ticket_status(self, ticket: JiraDatamodels.Issue, new_status: str) -> None:\n        ticket.status = new_status\n\n    def _set_ticket_update_time(\n        self, ticket: JiraDatamodels.Issue, update_time: datetime\n    ) -> None:\n        update_timestamp = update_time.timestamp()\n        ticket.updated_ms = int(update_timestamp) * consts.NUM_OF_MILLI_IN_SEC\n\n    def _update_ticket_description(self, ticket_id: str, description: str) -> None:\n        self.api_client.update_issue(ticket_id, fields={\"Description\": description})\n\n    def _update_ticket_severity(self, ticket_id: str, severity: str) -> None:\n        self.api_client.update_issue(issue_key=ticket_id, fields={\"Severity\": severity})\n\n    def _create_description_table(\n        self, findings: list[SCCEnterpriseDatamodels.FindingContext]\n    ) -> str:\n        return SCCEnterpriseUtils.create_jwm_table(\n            findings, self._soar_job.platform_url\n        )\n\n    def _update_description_table(self, table: str, description: str) -> str:\n        return SCCEnterpriseUtils.update_jira_wiki_desc_table(table, description)\n\n    def _parse_ticket_details_for_scc(\n        self, ticket: JiraDatamodels.Issue, **additional_keys\n    ) -> SCCEnterpriseDatamodels.ITSMTicketDetailsForSCC:\n        assignee = ticket.raw_data[\"fields\"].get(\"assignee\", NOT_AVAILABLE)\n        if not isinstance(assignee, str) and isinstance(assignee, dict):\n            assignee = assignee.get(\"displayName\", NOT_AVAILABLE)\n\n        ticket_details = SCCEnterpriseDatamodels.ITSMTicketDetailsForSCC(\n            id_=ticket.key,\n            assignee=assignee or NOT_AVAILABLE,  # assignee can exist but be \"\"\n            description=ticket.raw_data[\"fields\"][\"description\"],\n            uri=None,\n            status=ticket.status,\n            update_time=ticket.updated_ms // consts.NUM_OF_MILLI_IN_SEC,\n            **additional_keys,\n        )\n\n        # Updating the attr if exists or creating it if not\n        ticket_details.additional_keys[\"priority\"] = ticket.priority\n\n        return ticket_details\n\n\ndef main() -> None:\n    sync_job = SyncSCCJiraTicketsJob(\n        script_name=SYNC_SCC_JIRA_TICKETS,\n        integration_name=JiraConstants.INTEGRATION_NAME,\n    )\n    sync_job.start()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "creator": "Admin",
    "description": "This job will synchronize tickets in the Jira and Chronicle SOAR case. As a part of synchronization the job will work with comments and status of Chronicle SOAR cases.",
    "isEnabled": false,
    "isCustom": false,
    "version": 1,
    "parameters": [
        {
            "id": 1,
            "isMandatory": true,
            "name": "Environment",
            "type": 2,
            "value": "Default Environment"
        },
        {
            "id": 2,
            "isMandatory": true,
            "name": "API Root",
            "type": 2,
            "value": "https://google-team-gcr2cbk8.atlassian.net"
        },
        {
            "id": 3,
            "isMandatory": true,
            "name": "Username",
            "type": 2,
            "value": "marthasahithya@google.com"
        },
        {
            "id": 5,
            "isMandatory": true,
            "name": "Max Hours Backwards",
            "type": 1,
            "value": "24"
        },
        {
            "id": 6,
            "isMandatory": false,
            "name": "Verify SSL",
            "type": 0,
            "value": "false"
        },
        {
            "id": 4,
            "isMandatory": true,
            "name": "API Token",
            "type": 3,
            "value": "***************"
        }
    ],
    "runIntervalInSeconds": 600,
    "creationTime": "2025-06-27T09:36:53.243Z",
    "lastModificationTime": "2025-06-27T09:37:16.879Z",
    "isSystemJob": false,
    "jobDefinitionName": "Sync SCC-Jira Tickets",
    "agentIdentifier": null
}